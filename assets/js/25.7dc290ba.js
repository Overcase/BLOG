(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{218:function(t,n,o){"use strict";o.r(n);var e=o(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"content"},[n("p",[this._v("关于class实现继承后__proto__属性与Function继承差异\n")]),this._v(" "),n("p",[this._v("（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。\n（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n\nclass A {\n}\n\nclass B {\n}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n\n//《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。\n\nObject.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n\n")])])])])}],!1,null,null,null);s.options.__file="classDifference.md";n.default=s.exports}}]);