(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{232:function(e,l,t){"use strict";t.r(l);var _=t(0),v=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,l=e.$createElement,t=e._self._c||l;return t("div",{staticClass:"content"},[t("p",[e._v("Es6模块总结\n")]),e._v(" "),t("p",[e._v('ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。\n严格模式主要有以下限制。')]),e._v(" "),t("ul",[t("li",[e._v("变量必须声明后再使用")]),e._v(" "),t("li",[e._v("函数的参数不能有同名属性，否则报错")]),e._v(" "),t("li",[e._v("不能使用with语句")]),e._v(" "),t("li",[e._v("不能对只读属性赋值，否则报错")]),e._v(" "),t("li",[e._v("不能使用前缀 0 表示八进制数，否则报错")]),e._v(" "),t("li",[e._v("不能删除不可删除的属性，否则报错")]),e._v(" "),t("li",[e._v("不能删除变量delete prop，会报错，只能删除属性delete global[prop]")]),e._v(" "),t("li",[e._v("eval不会在它的外层作用域引入变量")]),e._v(" "),t("li",[e._v("eval和arguments不能被重新赋值")]),e._v(" "),t("li",[e._v("arguments不会自动反映函数参数的变化")]),e._v(" "),t("li",[e._v("不能使用arguments.callee")]),e._v(" "),t("li",[e._v("不能使用arguments.caller")]),e._v(" "),t("li",[e._v("禁止this指向全局对象")]),e._v(" "),t("li",[e._v("不能使用fn.caller和fn.arguments获取函数调用的堆栈")]),e._v(" "),t("li",[e._v("增加了保留字（比如protected、static和interface）")])]),e._v(" "),t("p",[e._v("上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。\n其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。")])])}],!1,null,null,null);v.options.__file="ES6modules.md";l.default=v.exports}}]);